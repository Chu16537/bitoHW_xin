# bitoHW_xin

## 第一題

解答:

死鎖，第一個 transfer 可能先鎖住 A，第二 transfer 可能鎖住 B 導致，導致兩條 transfer 要等待對方釋放鎖

解法:

1. 更改上鎖順序，統一由 ID 較小的先上鎖
1. 放入 chan，不過就跟鎖沒有關係了

## 第二題

1. key 優化，縮短長度
1. ZAdd 儲存，並指定 Score，方便讀取時可定範圍
1. 儲存時壓縮資料

## 第三題

解答:

rolling upgrade:不中斷應用程式，逐一將 pod 更新版本，讓使用者沒有斷線感覺

re-create:停止所有 pod 然後創建新版本

readiness probe:檢驗容器是否是可以使用狀態，假如可用則繼續升級其他，假如不可用就刪除 pod 所有 server 的 ip

## 第四題

B 它與查詢結果順序一致，不用額外排序

## 第五題

1. 添加區分與消費者，每個消費者訂閱不同區分
   - 缺點:不同區分無順序性
   - 解決方案:如果一定要順序性，請用單一區分
1. 使用 poll，併發所有 poll 訊息
   - 缺點:同一區分會沒有順序性，記錄當前消費 ID 會有問題
   - 解決方案:依序執行
1. 多群組，讓原本會執行太久的程式碼，拆成兩組程式碼，並且監聽相同區分資料並各別做事
   - 缺點:要規劃好如何拆解程式碼互不影響

## 第六題

1. [API 文件](./README_Q6.md)
1. [DockerFile](./Dockerfile)
1. [Unit test](./app/test/main_test.go)
